---
title: "Dashboard Carteira Inteligente"
author: "Gustavo Darmont de Faria Lima"
date: "2025-12-02"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
    theme: flatly
    css: ["custom.css"]
runtime: shiny
---

```{r setup, include=FALSE}
# Load required libraries
library(shiny)
library(flexdashboard)
library(yfR)
library(quantmod)
library(PerformanceAnalytics)
library(dplyr)
library(lubridate)
library(rbcb)
library(cluster)
library(factoextra)
library(ggplot2)
library(plotly)
library(DT)

# Optional: If rbcb is not available, we'll use a fixed CDI approximation
# library(rbcb)
```

```{r data-fetching, include=FALSE}
# ============================================================================
# STEP 1: DATA FETCHING & FEATURE ENGINEERING
# ============================================================================

# 1. Define Ticker Universe
# Top 30 Brazilian stocks (Ibovespa constituents - example tickers)
# Note: Adjust these to actual current Ibovespa constituents
ibovespa_stocks <- c(
  "PETR4.SA", "VALE3.SA", "ITUB4.SA", "BBDC4.SA", "ABEV3.SA",
  "WEGE3.SA", "MGLU3.SA", "RENT3.SA", "BBAS3.SA", "ELET3.SA",
  "RADL3.SA", "SUZB3.SA", "RAIL3.SA", "VIVT3.SA", "CMIG4.SA",
  "CSAN3.SA", "GGBR4.SA", "USIM5.SA", "GOAU4.SA", "CYRE3.SA",
  "BRAP4.SA", "KLBN11.SA", "UGPA3.SA", "CCRO3.SA", "HAPV3.SA",
  "PRIO3.SA", "TOTS3.SA", "BRKM5.SA", "DXCO3.SA", "CPLE6.SA"
)

# 10 Liquid ETFs
etfs <- c(
  "IVVB11.SA", "BOVA11.SA", "SMAL11.SA", "DIVO11.SA", "FIND11.SA",
  "ISUS11.SA", "SPXI11.SA", "BBSD11.SA", "HASH11.SA", "CRIP11.SA"
)

# Commodities and FX
commodities_fx <- c("BTC-USD", "GC=F", "BRL=X")

# Combine all tickers
all_tickers <- c(ibovespa_stocks, etfs, commodities_fx)

# 2. Function to Download Adjusted Prices
download_prices <- function(tickers, start_date = NULL, end_date = NULL) {
  # Default: last 5 years if not specified
  if (is.null(start_date)) {
    start_date <- Sys.Date() - years(5)
  }
  if (is.null(end_date)) {
    end_date <- Sys.Date()
  }
  
  # Use yfR for downloading
  prices_list <- list()
  
  for (ticker in tickers) {
    tryCatch({
      cat("Downloading", ticker, "...\n")
      df_price <- yf_get(
        tickers = ticker,
        first_date = start_date,
        last_date = end_date,
        freq_data = "daily"
      )
      
      if (nrow(df_price) > 0) {
        # Extract adjusted close prices
        prices_list[[ticker]] <- xts(
          df_price$price_adjusted,
          order.by = df_price$ref_date
        )
        names(prices_list[[ticker]]) <- ticker
      }
    }, error = function(e) {
      cat("Error downloading", ticker, ":", e$message, "\n")
    })
  }
  
  # Combine all prices into a single xts object
  if (length(prices_list) > 0) {
    prices_xts <- do.call(merge, prices_list)
    return(prices_xts)
  } else {
    return(NULL)
  }
}

# 3. Create Synthetic CDB (100% of CDI)
create_synthetic_cdb <- function(start_date = NULL, end_date = NULL) {
  # Default: last 5 years
  if (is.null(start_date)) {
    start_date <- Sys.Date() - years(5)
  }
  if (is.null(end_date)) {
    end_date <- Sys.Date()
  }
  
  # Try to get CDI from rbcb
  tryCatch({
    # Get CDI daily rate from rbcb
    cdi_data <- get_series(c(CDI = 12), start_date = start_date, end_date = end_date)
    
    if (!is.null(cdi_data) && nrow(cdi_data) > 0) {
      # Convert annual CDI to daily rate
      # CDI is typically quoted as annual percentage
      cdi_data$daily_rate <- (1 + cdi_data$CDI / 100)^(1/252) - 1
      
      # Create cumulative return series (starting at 100)
      cdi_data$cumulative <- cumprod(1 + cdi_data$daily_rate) * 100
      
      # Create xts object
      cdb_xts <- xts(
        cdi_data$cumulative,
        order.by = cdi_data$date
      )
      names(cdb_xts) <- "CDB_Synthetic"
      
      return(cdb_xts)
    }
  }, error = function(e) {
    cat("rbcb not available or error. Using fixed CDI approximation.\n")
  })
  
  # Fallback: Use fixed CDI approximation (typical CDI ~ 13-14% annually)
  # Adjust this value based on current market conditions
  annual_cdi <- 0.135  # 13.5% annual (adjust as needed)
  daily_cdi <- (1 + annual_cdi)^(1/252) - 1
  
  # Create date sequence (business days only)
  date_seq <- seq(from = start_date, to = end_date, by = "day")
  date_seq <- date_seq[weekdays(date_seq) %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")]
  
  # Create cumulative return series
  n_days <- length(date_seq)
  daily_returns <- rep(daily_cdi, n_days)
  cumulative <- cumprod(1 + daily_returns) * 100
  
  cdb_xts <- xts(cumulative, order.by = date_seq)
  names(cdb_xts) <- "CDB_Synthetic"
  
  return(cdb_xts)
}

# 4. Calculate Features: Annualized Return, Volatility, Sharpe Ratio
calculate_features <- function(prices_xts, risk_free_xts = NULL) {
  # Calculate daily returns
  returns_xts <- Return.calculate(prices_xts, method = "log")
  returns_xts <- returns_xts[-1, ]  # Remove first NA row
  
  # If risk-free rate provided, calculate excess returns
  if (!is.null(risk_free_xts)) {
    rf_returns <- Return.calculate(risk_free_xts, method = "log")
    rf_returns <- rf_returns[-1, ]
    
    # Align dates
    common_dates <- intersect(index(returns_xts), index(rf_returns))
    returns_xts <- returns_xts[common_dates, ]
    rf_returns <- rf_returns[common_dates, ]
    
    # Calculate excess returns
    excess_returns <- returns_xts - as.numeric(rf_returns)
  } else {
    excess_returns <- returns_xts
  }
  
  # Calculate features for each asset
  features_list <- list()
  
  for (i in 1:ncol(returns_xts)) {
    ticker <- names(returns_xts)[i]
    asset_returns <- returns_xts[, i]
    asset_returns <- asset_returns[!is.na(asset_returns)]
    
    if (length(asset_returns) > 0) {
      # Annualized Return (252 trading days)
      annual_return <- mean(asset_returns, na.rm = TRUE) * 252
      
      # Annualized Volatility
      annual_vol <- sd(asset_returns, na.rm = TRUE) * sqrt(252)
      
      # Sharpe Ratio (assuming Rf = CDI)
      if (!is.null(risk_free_xts)) {
        rf_annual <- mean(rf_returns, na.rm = TRUE) * 252
        sharpe <- (annual_return - rf_annual) / annual_vol
      } else {
        sharpe <- annual_return / annual_vol
      }
      
      features_list[[ticker]] <- data.frame(
        Ticker = ticker,
        Annualized_Return = annual_return,
        Annualized_Volatility = annual_vol,
        Sharpe_Ratio = sharpe,
        stringsAsFactors = FALSE
      )
    }
  }
  
  # Combine into single DataFrame
  features_df <- do.call(rbind, features_list)
  rownames(features_df) <- NULL
  
  return(features_df)
}

# Main execution function (to be called when needed)
fetch_and_calculate_features <- function(start_date = NULL, end_date = NULL) {
  cat("Step 1: Fetching market data...\n")
  
  # Download market prices
  prices_xts <- download_prices(all_tickers, start_date, end_date)
  
  # Create synthetic CDB
  cat("Step 2: Creating synthetic CDB...\n")
  cdb_xts <- create_synthetic_cdb(start_date, end_date)
  
  # Merge CDB with other prices
  if (!is.null(prices_xts) && !is.null(cdb_xts)) {
    # Align dates
    common_dates <- intersect(index(prices_xts), index(cdb_xts))
    prices_xts <- prices_xts[common_dates, ]
    cdb_xts <- cdb_xts[common_dates, ]
    
    # Combine
    all_prices_xts <- merge(prices_xts, cdb_xts)
  } else if (!is.null(cdb_xts)) {
    all_prices_xts <- cdb_xts
  } else {
    all_prices_xts <- prices_xts
  }
  
  # Calculate features
  cat("Step 3: Calculating features...\n")
  features_df <- calculate_features(all_prices_xts, cdb_xts)
  
  return(list(
    prices = all_prices_xts,
    cdb = cdb_xts,
    features = features_df
  ))
}
```

```{r global-data-loading, include=FALSE}
# ============================================================================
# OPTIMIZATION: GLOBAL DATA LOADING & CACHING
# ============================================================================

# Define cache file path
cache_file <- "market_data_cache.rds"

# Function to load data with caching
load_market_data <- function(force_update = FALSE) {
  
  # Check if cache exists and we are not forcing an update
  if (file.exists(cache_file) && !force_update) {
    cat("Loading market data from cache...\n")
    return(readRDS(cache_file))
  } else {
    cat("Cache not found or update forced. Downloading data...\n")
    
    # Call your existing function
    # Note: We are using the default 5 years defined in your function
    data_results <- fetch_and_calculate_features() 
    
    # Validate data before saving
    if (!is.null(data_results) && nrow(data_results$features) > 0) {
      saveRDS(data_results, cache_file)
      cat("Data saved to cache.\n")
      return(data_results)
    } else {
      warning("Data download failed. Returning NULL.")
      return(NULL)
    }
  }
}

# EXECUTE LOADING AT STARTUP
# This variable 'GLOBAL_MARKET_DATA' will be available to all sessions
GLOBAL_MARKET_DATA <- load_market_data()
```

```{r clustering, include=FALSE}
# ============================================================================
# STEP 2: K-MEANS CLUSTERING ENGINE
# ============================================================================

# 1. Normalize/Scale Features
normalize_features <- function(features_df) {
  # Extract numeric features (excluding Ticker)
  feature_cols <- c("Annualized_Return", "Annualized_Volatility", "Sharpe_Ratio")
  
  # Check if all required columns exist
  if (!all(feature_cols %in% names(features_df))) {
    stop("Required feature columns not found in features_df")
  }
  
  # Extract features matrix
  features_matrix <- as.matrix(features_df[, feature_cols])
  rownames(features_matrix) <- features_df$Ticker
  
  # Remove any rows with NA or Inf values
  valid_rows <- complete.cases(features_matrix) & 
                !is.infinite(rowSums(features_matrix))
  features_matrix <- features_matrix[valid_rows, ]
  
  # Standardize features (z-score normalization)
  # Scale: centers and scales the columns
  features_scaled <- scale(features_matrix)
  
  # Return both scaled matrix and valid tickers
  return(list(
    scaled_features = features_scaled,
    valid_tickers = rownames(features_scaled),
    original_features = features_df[features_df$Ticker %in% rownames(features_scaled), ]
  ))
}

# 2. Apply K-Means Clustering
apply_kmeans <- function(scaled_features, k = 4, nstart = 25, iter.max = 100) {
  # Apply K-Means algorithm
  kmeans_result <- kmeans(
    scaled_features,
    centers = k,
    nstart = nstart,      # Number of random starts
    iter.max = iter.max   # Maximum iterations
  )
  
  return(kmeans_result)
}

# 3. Elbow Method to Determine Optimal K
calculate_elbow_data <- function(scaled_features, k_max = 10) {
  # Calculate within-cluster sum of squares (WSS) for different k values
  wss <- numeric(k_max)
  
  for (k in 1:k_max) {
    kmeans_temp <- kmeans(scaled_features, centers = k, nstart = 10, iter.max = 50)
    wss[k] <- kmeans_temp$tot.withinss
  }
  
  # Create data frame for plotting
  elbow_df <- data.frame(
    k = 1:k_max,
    WSS = wss
  )
  
  return(elbow_df)
}

# Plot Elbow Method
plot_elbow_method <- function(elbow_df) {
  p <- ggplot(elbow_df, aes(x = k, y = WSS)) +
    geom_line(color = "steelblue", size = 1) +
    geom_point(color = "steelblue", size = 3) +
    labs(
      title = "Elbow Method for Optimal K",
      subtitle = "Within-Cluster Sum of Squares (WSS) vs. Number of Clusters",
      x = "Number of Clusters (k)",
      y = "Within-Cluster Sum of Squares (WSS)"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      plot.subtitle = element_text(size = 11, color = "gray50"),
      axis.title = element_text(size = 11)
    ) +
    scale_x_continuous(breaks = 1:max(elbow_df$k))
  
  return(p)
}

# 4. Generate Final Table with Cluster Assignments
create_cluster_assignments <- function(features_df, kmeans_result, valid_tickers) {
  # Create cluster assignments dataframe
  cluster_assignments <- data.frame(
    Ticker = valid_tickers,
    Cluster_ID = kmeans_result$cluster,
    stringsAsFactors = FALSE
  )
  
  # Merge with original features
  features_with_clusters <- merge(
    features_df,
    cluster_assignments,
    by = "Ticker",
    all.x = TRUE
  )
  
  # Order by Cluster_ID and then by Sharpe_Ratio (descending)
  features_with_clusters <- features_with_clusters[
    order(features_with_clusters$Cluster_ID, 
          -features_with_clusters$Sharpe_Ratio), 
  ]
  
  return(features_with_clusters)
}

# Main Clustering Function
perform_clustering <- function(features_df, k = 5, k_max_elbow = 10, 
                                plot_elbow = TRUE) {
  cat("Step 1: Normalizing features...\n")
  
  # Normalize features
  normalized_data <- normalize_features(features_df)
  scaled_features <- normalized_data$scaled_features
  valid_tickers <- normalized_data$valid_tickers
  
  if (length(valid_tickers) < k) {
    stop(paste("Not enough valid assets (", length(valid_tickers), 
               ") for k =", k, "clusters"))
  }
  
  cat("Step 2: Applying K-Means clustering (k =", k, ")...\n")
  
  # Apply K-Means
  kmeans_result <- apply_kmeans(scaled_features, k = k)
  
  cat("Step 3: Calculating elbow method data...\n")
  
  # Calculate elbow data
  elbow_df <- calculate_elbow_data(scaled_features, k_max = k_max_elbow)
  
  # Create elbow plot (optional)
  elbow_plot <- NULL
  if (plot_elbow) {
    elbow_plot <- plot_elbow_method(elbow_df)
  }
  
  cat("Step 4: Creating cluster assignments table...\n")
  
  # Create final assignments table
  cluster_assignments_df <- create_cluster_assignments(
    features_df,
    kmeans_result,
    valid_tickers
  )
  
  return(list(
    cluster_assignments = cluster_assignments_df,
    kmeans_model = kmeans_result,
    scaled_features = scaled_features,
    elbow_data = elbow_df,
    elbow_plot = elbow_plot,
    valid_tickers = valid_tickers
  ))
}
```

```{r cluster-plot-logic, include=FALSE}
# ============================================================================
# CLUSTER VISUALIZATION FUNCTION
# ============================================================================

create_cluster_plot <- function(cluster_assignments_df) {
  
  # Preparar dados para plotagem
  plot_df <- cluster_assignments_df %>%
    # Remover linhas NA que possam ter sido geradas por erros de download
    filter(!is.na(Cluster_ID)) %>%
    mutate(
      Cluster_ID = factor(Cluster_ID),
      # Identificar o ativo "Best in Class" (Maior Sharpe) por cluster
      Is_Best = Ticker %in% select_best_asset_per_cluster(cluster_assignments_df)$Ticker,
      
      # Formatar para exibição
      Sharpe_Ratio_Text = paste("Sharpe:", round(Sharpe_Ratio, 3)),
      Return_Text = paste("Retorno:", scales::percent(Annualized_Return, accuracy = 0.1)),
      Vol_Text = paste("Volatilidade:", scales::percent(Annualized_Volatility, accuracy = 0.1))
    )
  
  # Criar o gráfico base com ggplot2
  p <- ggplot(plot_df, aes(
    x = Annualized_Volatility, 
    y = Annualized_Return, 
    color = Cluster_ID,
    # Dados para o tooltip do Plotly
    customdata = Ticker,
    text = paste(
      "Ticker:", Ticker, "<br>",
      Return_Text, "<br>",
      Vol_Text, "<br>",
      Sharpe_Ratio_Text
    )
  )) +
    geom_point(aes(size = Sharpe_Ratio), alpha = 0.6) +
    # Destacar os ativos selecionados para o portfólio
    geom_point(data = filter(plot_df, Is_Best), 
               aes(fill = Cluster_ID), 
               shape = 21, color = "black", size = 5, stroke = 1.5) +
    # Adicionar centroides (opcional, requer o objeto kmeans_model)
    # geom_point(data = as.data.frame(kmeans_model$centers), ...) 
    
    scale_x_continuous(labels = scales::percent) +
    scale_y_continuous(labels = scales::percent) +
    labs(
      title = "Clusters de Ativos: Retorno vs. Volatilidade",
      x = "Volatilidade Anualizada",
      y = "Retorno Anualizado",
      color = "Cluster ID",
      size = "Sharpe Ratio"
    ) +
    theme_minimal() +
    theme(legend.position = "bottom")
  
  # Converter para Plotly para interatividade
  fig <- ggplotly(p, tooltip = "text") %>%
    layout(hoverlabel = list(bgcolor = "white"))
  
  return(fig)
}
```

```{r suitability-logic, include=FALSE}
# ============================================================================
# STEP 3: SUITABILITY QUESTIONNAIRE (CVM 539)
# ============================================================================

# Calculate Investor Profile Score based on CVM 539 rules
calculate_investor_profile <- function(answers) {
  # Initialize score
  score <- 0
  
  # Question 1: Time Horizon (0-25 points)
  # Longer horizon = higher risk tolerance
  if (answers$time_horizon == "Menos de 1 ano") {
    score <- score + 5
  } else if (answers$time_horizon == "1 a 3 anos") {
    score <- score + 10
  } else if (answers$time_horizon == "3 a 5 anos") {
    score <- score + 15
  } else if (answers$time_horizon == "5 a 10 anos") {
    score <- score + 20
  } else if (answers$time_horizon == "Mais de 10 anos") {
    score <- score + 25
  }
  
  # Question 2: Risk Tolerance (0-25 points)
  # Higher tolerance = higher score
  if (answers$risk_tolerance == "Muito Conservador") {
    score <- score + 5
  } else if (answers$risk_tolerance == "Conservador") {
    score <- score + 10
  } else if (answers$risk_tolerance == "Moderado") {
    score <- score + 15
  } else if (answers$risk_tolerance == "Arrojado") {
    score <- score + 20
  } else if (answers$risk_tolerance == "Muito Arrojado") {
    score <- score + 25
  }
  
  # Question 3: Financial Knowledge (0-20 points)
  # More knowledge = higher score
  if (answers$financial_knowledge == "Nenhum conhecimento") {
    score <- score + 0
  } else if (answers$financial_knowledge == "Básico") {
    score <- score + 5
  } else if (answers$financial_knowledge == "Intermediário") {
    score <- score + 10
  } else if (answers$financial_knowledge == "Avançado") {
    score <- score + 15
  } else if (answers$financial_knowledge == "Especialista") {
    score <- score + 20
  }
  
  # Question 4: Liquidity Needs (0-15 points)
  # Lower liquidity needs = higher score
  if (answers$liquidity_needs == "Muito alta (preciso acessar o dinheiro a qualquer momento)") {
    score <- score + 0
  } else if (answers$liquidity_needs == "Alta (posso esperar alguns meses)") {
    score <- score + 5
  } else if (answers$liquidity_needs == "Média (posso esperar até 1 ano)") {
    score <- score + 10
  } else if (answers$liquidity_needs == "Baixa (posso esperar vários anos)") {
    score <- score + 15
  }
  
  # Question 5: % of Income Invested (0-15 points)
  # Higher percentage = higher score (shows commitment)
  if (answers$income_percentage == "Menos de 5%") {
    score <- score + 3
  } else if (answers$income_percentage == "5% a 10%") {
    score <- score + 6
  } else if (answers$income_percentage == "10% a 20%") {
    score <- score + 9
  } else if (answers$income_percentage == "20% a 30%") {
    score <- score + 12
  } else if (answers$income_percentage == "Mais de 30%") {
    score <- score + 15
  }
  
  # Determine profile based on score
  if (score <= 35) {
    profile <- "Conservative"
    profile_pt <- "Conservador"
  } else if (score <= 65) {
    profile <- "Moderate"
    profile_pt <- "Moderado"
  } else {
    profile <- "Aggressive"
    profile_pt <- "Agressivo"
  }
  
  return(list(
    score = score,
    profile = profile,
    profile_pt = profile_pt,
    max_score = 100
  ))
}
```

```{r backtesting-logic, include=FALSE}
# ============================================================================
# STEP 5: BACKTESTING & RISK ENGINE
# ============================================================================

calculate_backtest_performance <- function(portfolio_df, market_data) {
  
  # 1. Prepare Data
  # Extract tickers and weights from recommended portfolio
  target_tickers <- portfolio_df$Ticker
  weights <- portfolio_df$Weight
  names(weights) <- target_tickers
  
  # Get historical prices for the selected assets
  asset_prices <- market_data$prices[, target_tickers]
  
  # Calculate asset daily returns
  asset_returns <- Return.calculate(asset_prices, method = "log")
  asset_returns <- asset_returns[-1, ] # Remove first NA
  asset_returns <- na.omit(asset_returns) # Ensure clean data
  
  # 2. Calculate Portfolio Returns
  # We assume daily rebalancing to fixed weights for the backtest
  portfolio_ret <- Return.portfolio(asset_returns, weights = weights, rebalance_on = "days")
  names(portfolio_ret) <- "Carteira_Recomendada"
  
  # 3. Calculate Benchmarks
  
  # A. Equal Weights Portfolio (Neutral Strategy)
  n_assets <- length(target_tickers)
  eq_weights <- rep(1/n_assets, n_assets)
  ew_ret <- Return.portfolio(asset_returns, weights = eq_weights, rebalance_on = "days")
  names(ew_ret) <- "Benchmark_Pesos_Iguais"
  
  # B. CDI (Risk Free / Market Benchmark)
  # Extract CDI prices from market_data (CDB_Synthetic)
  cdi_prices <- market_data$cdb
  cdi_ret <- Return.calculate(cdi_prices, method = "log")[-1, ]
  names(cdi_ret) <- "CDI_CDB"
  
  # 4. Merge All Series
  # Align dates across all series
  all_ret <- merge(portfolio_ret, ew_ret, cdi_ret)
  all_ret <- na.omit(all_ret)
  
  # 5. Calculate Cumulative Returns (Wealth Index)
  # Starting at 100
  wealth_index <- cumprod(1 + all_ret) * 100
  
  # 6. Calculate Risk Metrics (for the Recommended Portfolio only)
  # Total Return (Cumulative)
  total_return <- tail(wealth_index$Carteira_Recomendada, 1) / 100 - 1
  
  # Annualized Volatility
  ann_vol <- StdDev.annualized(portfolio_ret, scale = 252)
  
  # Parametric VaR (95%)
  # method = "gaussian" uses mean and std dev
  var_95 <- VaR(portfolio_ret, p = 0.95, method = "gaussian")
  
  # Max Drawdown
  max_dd <- maxDrawdown(portfolio_ret)
  
  return(list(
    daily_returns = all_ret,
    wealth_index = wealth_index,
    metrics = list(
      total_return = as.numeric(total_return),
      volatility = as.numeric(ann_vol),
      var_95 = as.numeric(var_95),
      max_drawdown = as.numeric(max_dd)
    )
  ))
}
```

```{r monte-carlo-logic, include=FALSE}
# ============================================================================
# STEP 6: MONTE CARLO PROJECTION ENGINE (Geometric Brownian Motion)
# ============================================================================

# Parâmetros de input para a simulação (usados como valores iniciais)
initial_investment_default <- 10000
monthly_contribution_default <- 500
n_years <- 5
n_simulations <- 100
n_trading_days_year <- 252

run_monte_carlo_gbm <- function(portfolio_metrics) {
  
  # 1. Extrair Parâmetros do Portfólio
  mu <- portfolio_metrics$expected_return # Retorno Anualizado
  sigma <- portfolio_metrics$expected_volatility # Volatilidade Anualizada
  
  # 2. Parâmetros da Simulação (em passos diários para 5 anos)
  # O tempo total da simulação (T) é 5 anos
  # O número de passos (N) é 5 anos * 252 dias/ano
  N <- n_years * n_trading_days_year
  dt <- 1 / n_trading_days_year  # Passo de tempo (1 dia)
  
  # 3. Executar as Simulações
  simulated_paths <- matrix(NA, nrow = N + 1, ncol = n_simulations)
  
  # Preencher a primeira linha (Dia 0) com o valor de 1 (para cálculo de retorno)
  simulated_paths[1, ] <- 1
  
  for (j in 1:n_simulations) {
    # Criar ruído (componente estocástica)
    epsilon <- rnorm(N, mean = 0, sd = 1)
    
    # Calcular o retorno diário (dR) usando GBM
    daily_returns <- (mu - 0.5 * sigma^2) * dt + sigma * sqrt(dt) * epsilon
    
    # Calcular o valor acumulado (Wealth Index)
    for (i in 1:N) {
      simulated_paths[i + 1, j] <- simulated_paths[i, j] * exp(daily_returns[i])
    }
  }
  
  # 4. Processar Resultados e Estatísticas
  # Adicionar coluna de dias
  sim_df <- data.frame(Day = 0:N)
  
  # Transpor e adicionar caminhos simulados
  sim_paths_df <- as.data.frame(simulated_paths)
  names(sim_paths_df) <- paste0("Path_", 1:n_simulations)
  
  # Merge com o índice de dias
  sim_df <- cbind(sim_df, sim_paths_df)
  
  # Calcular percentis e mediana
  sim_df$Median <- apply(simulated_paths, 1, median)
  sim_df$P05 <- apply(simulated_paths, 1, quantile, probs = 0.05)
  sim_df$P95 <- apply(simulated_paths, 1, quantile, probs = 0.95)
  
  # Adicionar data fictícia para o gráfico (para eixo X)
  start_date <- Sys.Date()
  sim_df$Date <- seq(from = start_date, by = "day", length.out = N + 1)
  
  return(sim_df)
}

# Função auxiliar para calcular o valor final com contribuições
calculate_final_value <- function(mc_df, initial_investment, monthly_contribution, metrics) {
  
  # Usa a Mediana (P50) como projeção central
  median_return_factor <- tail(mc_df$Median, 1)
  
  # 1. Projeção de Investimento Inicial
  final_value_initial <- initial_investment * median_return_factor
  
  # 2. Projeção de Contribuições Mensais
  # Usa a taxa anual de retorno vinda explicitamente do argumento 'metrics'
  monthly_rate <- (1 + metrics$expected_return)^(1/12) - 1
  n_periods <- n_years * 12
  
  # Valor Futuro de uma Série de Pagamentos (Anuidade)
  final_value_contributions <- monthly_contribution * (( (1 + monthly_rate)^n_periods - 1) / monthly_rate) * (1 + monthly_rate)
  
  final_value <- final_value_initial + final_value_contributions
  
  # Calcular os cenários final P05 e P95
  p05_factor <- tail(mc_df$P05, 1)
  p95_factor <- tail(mc_df$P95, 1)
  
  # Valor Final no Cenário P05
  final_p05 <- (initial_investment * p05_factor) + 
               (monthly_contribution * (( (1 + monthly_rate)^n_periods - 1) / monthly_rate) * (1 + monthly_rate))
  
  # Valor Final no Cenário P95
  final_p95 <- (initial_investment * p95_factor) + 
               (monthly_contribution * (( (1 + monthly_rate)^n_periods - 1) / monthly_rate) * (1 + monthly_rate))
  
  return(list(
    final_value = final_value,
    final_p05 = final_p05,
    final_p95 = final_p95,
    n_years = n_years
  ))
}
```

```{r ui-components}
# ============================================================================
# SHINY UI COMPONENTS
# ============================================================================

# Tab 1: Input / Suitability Questionnaire
input_tab <- function() {
  fluidPage(
    titlePanel("Questionário de Adequação - CVM 539"),
    br(),
    
    wellPanel(
      h4("Instruções"),
      p("Por favor, responda todas as questões abaixo para determinar seu perfil de investidor. 
        As respostas são baseadas nas diretrizes da Instrução CVM 539."),
      style = "background-color: #f8f9fa; padding: 15px; border-radius: 5px;"
    ),
    
    br(),
    
    # Question 1: Time Horizon
    wellPanel(
      h5("1. Qual é o seu horizonte de investimento?"),
      radioButtons(
        inputId = "time_horizon",
        label = NULL,
        choices = list(
          "Menos de 1 ano" = "Menos de 1 ano",
          "1 a 3 anos" = "1 a 3 anos",
          "3 a 5 anos" = "3 a 5 anos",
          "5 a 10 anos" = "5 a 10 anos",
          "Mais de 10 anos" = "Mais de 10 anos"
        ),
        selected = character(0)
      )
    ),
    
    # Question 2: Risk Tolerance
    wellPanel(
      h5("2. Qual é a sua tolerância ao risco?"),
      radioButtons(
        inputId = "risk_tolerance",
        label = NULL,
        choices = list(
          "Muito Conservador (não aceito perdas)" = "Muito Conservador",
          "Conservador (aceito pequenas perdas)" = "Conservador",
          "Moderado (aceito perdas moderadas)" = "Moderado",
          "Arrojado (aceito perdas significativas)" = "Arrojado",
          "Muito Arrojado (aceito altas volatilidades)" = "Muito Arrojado"
        ),
        selected = character(0)
      )
    ),
    
    # Question 3: Financial Knowledge
    wellPanel(
      h5("3. Qual é o seu nível de conhecimento sobre investimentos?"),
      radioButtons(
        inputId = "financial_knowledge",
        label = NULL,
        choices = list(
          "Nenhum conhecimento" = "Nenhum conhecimento",
          "Básico (conheço poupança e CDB)" = "Básico",
          "Intermediário (conheço ações e fundos)" = "Intermediário",
          "Avançado (conheço derivativos e alavancagem)" = "Avançado",
          "Especialista (trabalho na área financeira)" = "Especialista"
        ),
        selected = character(0)
      )
    ),
    
    # Question 4: Liquidity Needs
    wellPanel(
      h5("4. Qual é a sua necessidade de liquidez?"),
      radioButtons(
        inputId = "liquidity_needs",
        label = NULL,
        choices = list(
          "Muito alta (preciso acessar o dinheiro a qualquer momento)" = "Muito alta (preciso acessar o dinheiro a qualquer momento)",
          "Alta (posso esperar alguns meses)" = "Alta (posso esperar alguns meses)",
          "Média (posso esperar até 1 ano)" = "Média (posso esperar até 1 ano)",
          "Baixa (posso esperar vários anos)" = "Baixa (posso esperar vários anos)"
        ),
        selected = character(0)
      )
    ),
    
    # Question 5: % of Income
    wellPanel(
      h5("5. Qual percentual da sua renda você pretende investir?"),
      radioButtons(
        inputId = "income_percentage",
        label = NULL,
        choices = list(
          "Menos de 5%" = "Menos de 5%",
          "5% a 10%" = "5% a 10%",
          "10% a 20%" = "10% a 20%",
          "20% a 30%" = "20% a 30%",
          "Mais de 30%" = "Mais de 30%"
        ),
        selected = character(0)
      )
    ),
    
    br(),
    
    # Generate Portfolio Button
    div(
      actionButton(
        inputId = "generate_portfolio",
        label = "Gerar Carteira Recomendada",
        class = "btn-primary btn-lg",
        style = "width: 100%; padding: 15px; font-size: 16px;"
      ),
      align = "center"
    ),
    
    br(),
    
    # Display Profile Results
    conditionalPanel(
      condition = "output.profile_calculated == true",
      wellPanel(
        h4("Seu Perfil de Investidor"),
        verbatimTextOutput("investor_profile_output"),
        style = "background-color: #e7f3ff; padding: 15px; border-radius: 5px; border: 2px solid #2196F3;"
      )
    )
  )
}

# Tab 2: Results / Dashboard
results_tab <- function() {
  fluidPage(
    titlePanel("Carteira Recomendada"),
    
    # Portfolio Metrics Summary
    conditionalPanel(
      condition = "output.portfolio_generated == true",
      fluidRow(
        column(12,
          wellPanel(
            h4("Métricas da Carteira"),
            fluidRow(
              column(4,
                h5("Retorno Esperado (Anualizado)"),
                verbatimTextOutput("portfolio_return", placeholder = TRUE)
              ),
              column(4,
                h5("Volatilidade Esperada (Anualizada)"),
                verbatimTextOutput("portfolio_volatility", placeholder = TRUE)
              ),
              column(4,
                h5("Sharpe Ratio"),
                verbatimTextOutput("portfolio_sharpe", placeholder = TRUE)
              )
            ),
            style = "background-color: #f0f8ff; padding: 15px; border-radius: 5px;"
          )
        )
      )
    ),
    
    br(),
    
    # Donut Chart
    conditionalPanel(
      condition = "output.portfolio_generated == true",
      fluidRow(
        column(12,
          h4("Alocação da Carteira"),
          plotlyOutput("portfolio_donut_chart", height = "500px")
        )
      )
    ),
    
    br(),
    
    # Portfolio Table
    conditionalPanel(
      condition = "output.portfolio_generated == true",
      fluidRow(
        column(12,
          h4("Composição Detalhada da Carteira"),
          DT::dataTableOutput("portfolio_table")
        )
      )
    ),
    
    # Placeholder when portfolio not generated
    conditionalPanel(
      condition = "output.portfolio_generated == false",
      wellPanel(
        h4("Aguardando Geração da Carteira"),
        p("Complete o questionário na aba 'Entrada de Dados' e clique em 'Gerar Carteira Recomendada' para ver os resultados aqui."),
        style = "background-color: #fff9e6; padding: 20px; border-radius: 5px; text-align: center;"
      )
    )
  )
}
```

```{r server-logic}
# ============================================================================
# SHINY SERVER LOGIC
# ============================================================================

# Reactive values to store investor profile
investor_profile <- reactiveValues(
  score = NULL,
  profile = NULL,
  profile_pt = NULL,
  calculated = FALSE
)

# Reactive values to store portfolio data and Market Data
portfolio_data <- reactiveValues(
  portfolio_df = NULL,
  portfolio_metrics = NULL,
  generated = FALSE,
  market_data = GLOBAL_MARKET_DATA,
  clustering_results = NULL
)

# Event: Generate Portfolio Button Clicked
observeEvent(input$generate_portfolio, {
  # Validate all questions are answered
  if (is.null(input$time_horizon) || 
      is.null(input$risk_tolerance) || 
      is.null(input$financial_knowledge) || 
      is.null(input$liquidity_needs) || 
      is.null(input$income_percentage)) {
    
    showNotification(
      "Por favor, responda todas as questões antes de gerar a carteira.",
      type = "warning",
      duration = 5
    )
    return()
  }
  
  # Collect answers
  answers <- list(
    time_horizon = input$time_horizon,
    risk_tolerance = input$risk_tolerance,
    financial_knowledge = input$financial_knowledge,
    liquidity_needs = input$liquidity_needs,
    income_percentage = input$income_percentage
  )
  
  # Calculate profile
  profile_result <- calculate_investor_profile(answers)
  
  # Store in reactive values
  investor_profile$score <- profile_result$score
  investor_profile$profile <- profile_result$profile
  investor_profile$profile_pt <- profile_result$profile_pt
  investor_profile$calculated <- TRUE
  
  # Show notification
  showNotification(
    paste0("Perfil calculado: ", profile_result$profile_pt, " (Score: ", 
           profile_result$score, "/100)"),
    type = "message",
    duration = 5
  )
  
  # Trigger portfolio generation
  # This will be handled in a separate observeEvent for the button
})

observe({
  
  # 1. GATILHOS (Triggers)
  req(investor_profile$calculated == TRUE)
  
  # NOVO GATILHO: Força o recálculo sempre que o perfil (Conservador/Moderado/Agressivo) mudar
  profile_trigger <- investor_profile$profile 
  
  k_value <- input$num_assets 
  req(k_value >= 4)
  
  # Gatilhos financeiros (para atualizar projeção se mudar o valor)
  inv_inicial <- input$initial_investment
  aport_mensal <- input$monthly_contribution
  
  # 2. Dados de Mercado
  market_results <- portfolio_data$market_data
  req(!is.null(market_results))
  
  # --- ISOLATE ---
  # Isolamos o processamento pesado para evitar loops, 
  # mas usamos os valores capturados acima (k_value, inv_inicial, etc)
  isolate({ 
    
    showNotification(
      paste0("Calculando cenários (k=", k_value, ")..."),
      type = "message", duration = 3, id = "recalculating"
    )
    
    tryCatch({
      # --- PIPELINE DE CÁLCULO ---
      
      # Step 2: Clustering
      clustering_results <- perform_clustering(
        market_results$features,
        k = k_value,
        plot_elbow = FALSE
      )
      
      # Step 3: Portfolio Construction
      portfolio_result <- construct_portfolio(
        clustering_results$cluster_assignments,
        investor_profile$profile,
        n_clusters = k_value
      )
      
      # Step 4: Backtest
      backtest_results <- calculate_backtest_performance(
        portfolio_result$portfolio,
        market_results
      )
      
      # Step 6: Monte Carlo
      monte_carlo_df <- run_monte_carlo_gbm(portfolio_result$portfolio_metrics)
      
      # Step 6b: Valor Final (CORREÇÃO AQUI)
      # Passamos 'portfolio_result$portfolio_metrics' explicitamente
      final_value_results <- calculate_final_value(
        mc_df = monte_carlo_df,
        initial_investment = inv_inicial,    # Valor capturado do input
        monthly_contribution = aport_mensal, # Valor capturado do input
        metrics = portfolio_result$portfolio_metrics # <--- O PULO DO GATO
      )
      
      # --- ARMAZENAMENTO ---
      portfolio_data$portfolio_df <- portfolio_result$portfolio
      portfolio_data$portfolio_metrics <- portfolio_result$portfolio_metrics
      portfolio_data$clustering_results <- clustering_results
      portfolio_data$backtest_results <- backtest_results
      portfolio_data$monte_carlo_results_df <- monte_carlo_df
      portfolio_data$monte_carlo_results <- final_value_results
      portfolio_data$generated <- TRUE 
      
      removeNotification("recalculating")
      
    }, error = function(e) {
      removeNotification("recalculating")
      showNotification(paste0("Erro: ", e$message), type = "error", duration = 10)
    })
  }) 
}, priority = 1)

# Event: Update Data Button
    observeEvent(input$update_data, {
      showNotification("Atualizando dados de mercado... Isso pode demorar.", type = "message", id = "updating")
      
      tryCatch({
        # Force update using the function we created in Step 1
        new_data <- load_market_data(force_update = TRUE)
        
        if (!is.null(new_data)) {
          # Update the reactive value so the app sees the new data
          portfolio_data$market_data <- new_data
          
          # Optional: Update the global variable for future sessions (if running locally)
          GLOBAL_MARKET_DATA <<- new_data
          
          showNotification("Dados atualizados com sucesso!", type = "message")
        } else {
          showNotification("Falha ao baixar dados.", type = "error")
        }
      }, error = function(e) {
        showNotification(paste("Erro:", e$message), type = "error")
      }, finally = {
        removeNotification("updating")
      })
    })

# Output: Investor Profile Display
output$investor_profile_output <- renderText({
  if (investor_profile$calculated) {
    paste0(
      "Perfil: ", investor_profile$profile_pt, "\n",
      "Score: ", investor_profile$score, " / ", 100, "\n",
      "Nível de Risco: ", 
      ifelse(investor_profile$profile == "Conservative", "Baixo",
             ifelse(investor_profile$profile == "Moderate", "Médio", "Alto"))
    )
  } else {
    "Complete o questionário e clique em 'Gerar Carteira Recomendada'"
  }
})

# Output: Profile Calculated Flag (for conditionalPanel)
output$profile_calculated <- reactive({
  investor_profile$calculated
})
outputOptions(output, "profile_calculated", suspendWhenHidden = FALSE)

# Output: Portfolio Generated Flag
output$portfolio_generated <- reactive({
  portfolio_data$generated
})
outputOptions(output, "portfolio_generated", suspendWhenHidden = FALSE)

# Output: Portfolio Metrics
output$portfolio_return <- renderText({
  if (portfolio_data$generated && !is.null(portfolio_data$portfolio_metrics)) {
    paste0(round(portfolio_data$portfolio_metrics$expected_return * 100, 2), "%")
  } else {
    "-"
  }
})

output$portfolio_volatility <- renderText({
  if (portfolio_data$generated && !is.null(portfolio_data$portfolio_metrics)) {
    paste0(round(portfolio_data$portfolio_metrics$expected_volatility * 100, 2), "%")
  } else {
    "-"
  }
})

output$portfolio_sharpe <- renderText({
  if (portfolio_data$generated && !is.null(portfolio_data$portfolio_metrics)) {
    round(portfolio_data$portfolio_metrics$sharpe_ratio, 3)
  } else {
    "-"
  }
})

# Output: Cluster Visualization Plot
output$cluster_plot <- renderPlotly({
  if (portfolio_data$generated && !is.null(portfolio_data$clustering_results)) {
    
    # Extrai o dataframe de atribuições de cluster
    cluster_df <- portfolio_data$clustering_results$cluster_assignments
    
    # Gera o gráfico
    create_cluster_plot(cluster_df)
    
  } else {
    plotly_empty() %>%
      layout(title = "Aguardando Clusters de Ativos")
  }
})

# Output: Portfolio Donut Chart
output$portfolio_donut_chart <- renderPlotly({
  if (portfolio_data$generated && !is.null(portfolio_data$portfolio_df)) {
    create_portfolio_donut_chart(portfolio_data$portfolio_df)
  } else {
    plotly_empty() %>%
      layout(
        title = "Aguardando geração da carteira",
        xaxis = list(visible = FALSE),
        yaxis = list(visible = FALSE)
      )
  }
})

# Output: Portfolio Table
output$portfolio_table <- DT::renderDataTable({
  if (portfolio_data$generated && !is.null(portfolio_data$portfolio_df)) {
    display_df <- portfolio_data$portfolio_df %>%
      mutate(
        Weight = round(Weight * 100, 2),
        Annualized_Return = round(Annualized_Return * 100, 2),
        Annualized_Volatility = round(Annualized_Volatility * 100, 2),
        Sharpe_Ratio = round(Sharpe_Ratio, 3)
      ) %>%
      rename(
        "Ticker" = Ticker,
        "Cluster" = Cluster_ID,
        "Peso (%)" = Weight,
        "Retorno Anual (%)" = Annualized_Return,
        "Volatilidade Anual (%)" = Annualized_Volatility,
        "Sharpe Ratio" = Sharpe_Ratio
      )
    
    DT::datatable(
      display_df,
      options = list(
        pageLength = 10,
        searching = FALSE,
        ordering = TRUE,
        dom = 't'
      ),
      rownames = FALSE
    ) %>%
      DT::formatStyle(
        "Peso (%)",
        backgroundColor = DT::styleInterval(
          c(10, 20, 30),
          c("#ffebee", "#fff3e0", "#e8f5e9", "#e3f2fd")
        )
      )
  } else {
    data.frame(Message = "Aguardando geração da carteira")
  }
})

# Output: Wealth Index Chart (Interactive)
output$wealth_index_chart <- renderPlotly({
  if (portfolio_data$generated && !is.null(portfolio_data$backtest_results)) {
    
    # Extract data for plotting
    wealth_xts <- portfolio_data$backtest_results$wealth_index
    
    # Convert to dataframe for Plotly
    df_plot <- data.frame(
      Date = index(wealth_xts),
      Carteira = as.numeric(wealth_xts$Carteira_Recomendada),
      Benchmark_EW = as.numeric(wealth_xts$Benchmark_Pesos_Iguais),
      CDI = as.numeric(wealth_xts$CDI_CDB)
    )
    
    # Create Plot
    plot_ly(df_plot, x = ~Date) %>%
      add_trace(y = ~Carteira, name = 'Carteira Recomendada', type = 'scatter', mode = 'lines',
                line = list(color = '#2e7d32', width = 3)) %>%
      add_trace(y = ~CDI, name = 'CDI (Risk Free)', type = 'scatter', mode = 'lines',
                line = list(color = '#000000', width = 1, dash = 'dash')) %>%
      add_trace(y = ~Benchmark_EW, name = 'Benchmark (Pesos Iguais)', type = 'scatter', mode = 'lines',
                line = list(color = '#1976d2', width = 1)) %>%
      layout(
        title = "Evolução Patrimonial (Base 100)",
        xaxis = list(title = ""),
        yaxis = list(title = "Valor Acumulado"),
        legend = list(orientation = "h", x = 0.1, y = -0.2),
        hovermode = "x unified"
      )
    
  } else {
    plotly_empty()
  }
})

# Output: Monte Carlo Projection Chart
output$monte_carlo_projection <- renderPlotly({
  if (portfolio_data$generated && !is.null(portfolio_data$monte_carlo_results_df)) {
    
    mc_df <- portfolio_data$monte_carlo_results_df
    
    # Plotly: Long format is easier for paths
    df_long <- mc_df %>%
      select(Date, starts_with("Path_")) %>%
      tidyr::pivot_longer(cols = starts_with("Path_"), names_to = "Simulation", values_to = "Value")
    
    fig <- plot_ly(df_long, x = ~Date) %>%
      # Plotar todos os caminhos (alta transparência)
      add_trace(y = ~Value, type = 'scatter', mode = 'lines',
                line = list(color = 'rgba(100, 100, 100, 0.1)'),
                group = ~Simulation, showlegend = FALSE) %>%
      
      # Plotar Cenário Otimista (P95)
      add_trace(data = mc_df, y = ~P95, name = 'Cenário Otimista (P95)', type = 'scatter', mode = 'lines',
                line = list(color = 'rgba(46, 125, 50, 0.8)', width = 2)) %>%
      
      # Plotar Mediana (P50)
      add_trace(data = mc_df, y = ~Median, name = 'Mediana (P50)', type = 'scatter', mode = 'lines',
                line = list(color = '#1976d2', width = 3)) %>%
      
      # Plotar Cenário Pessimista (P05)
      add_trace(data = mc_df, y = ~P05, name = 'Cenário Pessimista (P05)', type = 'scatter', mode = 'lines',
                line = list(color = 'rgba(211, 47, 47, 0.8)', width = 2)) %>%
      
      layout(
        title = paste("Projeção do Retorno (100 Simulações)"),
        xaxis = list(title = "Data"),
        yaxis = list(title = "Índice de Riqueza (Base 1)"),
        hovermode = "x unified"
      )
    
    return(fig)
    
  } else {
    plotly_empty()
  }
})

# Output: Drawdown Chart
output$drawdown_chart <- renderPlotly({
  if (portfolio_data$generated && !is.null(portfolio_data$backtest_results)) {
    
    # Extrai os retornos do portfólio
    returns_xts <- portfolio_data$backtest_results$daily_returns[, "Carteira_Recomendada"]
    
    # 1. Calcula a série de Drawdowns (usando PerformanceAnalytics)
    dd_xts <- Drawdowns(returns_xts)
    
    # 2. Converte para dataframe para Plotly
    df_plot <- data.frame(
      Date = index(dd_xts),
      Drawdown = as.numeric(dd_xts)
    )
    
    # 3. Cria o gráfico Plotly (Área preenchida para visualização de perdas)
    fig <- plot_ly(df_plot, x = ~Date, y = ~Drawdown, type = 'scatter', mode = 'lines',
                   fill = 'tozeroy', 
                   line = list(color = '#d32f2f'), # Cor vermelha (perda)
                   fillcolor = 'rgba(211, 47, 47, 0.4)') %>%
      layout(
        title = "Série Histórica de Drawdown (%)",
        xaxis = list(title = ""),
        # Formata o eixo Y para porcentagem
        yaxis = list(title = "Perda Máxima (Perda/Ganho)", tickformat = "%"), 
        hovermode = "x unified"
      )
    
    return(fig)
    
  } else {
    plotly_empty() %>%
      layout(title = "Aguardando geração da série de Drawdown")
  }
})
```

```{r portfolio-construction, include=FALSE}
# ============================================================================
# STEP 4: PORTFOLIO CONSTRUCTION & OPTIMIZATION
# ============================================================================

# 1. Define Target Weights for Clusters Based on Investor Profile
get_cluster_weights_by_profile <- function(profile, n_clusters) {
  # Define weight allocation strategies for each profile
  # Weights are distributed across clusters based on risk-return characteristics
  
  if (profile == "Conservative") {
    # Conservative: Favor lower volatility clusters (typically lower cluster IDs after sorting)
    # More weight on safer clusters, less on risky ones
    if (n_clusters == 4) {
      # Assume clusters are ordered by risk (1 = lowest risk, 4 = highest risk)
      weights <- c(0.40, 0.30, 0.20, 0.10)  # Heavily weighted to low-risk clusters
    } else if (n_clusters == 5) {
      weights <- c(0.35, 0.25, 0.20, 0.15, 0.05)
    } else {
      # Generic: decreasing weights
      weights <- rev(seq(0.05, 0.40, length.out = n_clusters))
      weights <- weights / sum(weights)  # Normalize
    }
  } else if (profile == "Moderate") {
    # Moderate: Balanced allocation across clusters
    if (n_clusters == 4) {
      weights <- c(0.30, 0.25, 0.25, 0.20)  # More balanced
    } else if (n_clusters == 5) {
      weights <- c(0.25, 0.20, 0.20, 0.20, 0.15)
    } else {
      # Generic: equal weights with slight preference for middle clusters
      weights <- rep(1/n_clusters, n_clusters)
    }
  } else {  # Aggressive
    # Aggressive: Favor higher return clusters (typically higher cluster IDs)
    # More weight on riskier, higher-return clusters
    if (n_clusters == 4) {
      weights <- c(0.10, 0.20, 0.30, 0.40)  # Heavily weighted to high-risk clusters
    } else if (n_clusters == 5) {
      weights <- c(0.05, 0.15, 0.20, 0.25, 0.35)
    } else {
      # Generic: increasing weights
      weights <- seq(0.05, 0.40, length.out = n_clusters)
      weights <- weights / sum(weights)  # Normalize
    }
  }
  
  # Ensure weights sum to 1
  weights <- weights / sum(weights)
  
  return(weights)
}

# 2. Select Best Asset from Each Cluster (Highest Sharpe Ratio)
select_best_asset_per_cluster <- function(cluster_assignments_df) {
  # Group by cluster and select asset with highest Sharpe Ratio
  best_assets <- cluster_assignments_df %>%
    group_by(Cluster_ID) %>%
    slice_max(Sharpe_Ratio, n = 1, with_ties = FALSE) %>%
    ungroup() %>%
    arrange(Cluster_ID)
  
  return(best_assets)
}

# 3. Construct Recommended Portfolio
construct_portfolio <- function(cluster_assignments_df, investor_profile, n_clusters = NULL) {
  # Determine number of clusters if not provided
  if (is.null(n_clusters)) {
    n_clusters <- length(unique(cluster_assignments_df$Cluster_ID[!is.na(cluster_assignments_df$Cluster_ID)]))
  }
  
  # Get cluster weights based on profile
  cluster_weights <- get_cluster_weights_by_profile(investor_profile, n_clusters)
  
  # Select best asset from each cluster
  best_assets <- select_best_asset_per_cluster(cluster_assignments_df)
  
  # Check if we have enough clusters
  if (nrow(best_assets) < n_clusters) {
    warning("Not enough clusters found. Adjusting weights.")
    n_clusters <- nrow(best_assets)
    cluster_weights <- cluster_weights[1:n_clusters]
    cluster_weights <- cluster_weights / sum(cluster_weights)
  }
  
  # Create portfolio dataframe
  portfolio_df <- data.frame(
    Ticker = best_assets$Ticker,
    Cluster_ID = best_assets$Cluster_ID,
    Weight = cluster_weights[1:nrow(best_assets)],
    Annualized_Return = best_assets$Annualized_Return,
    Annualized_Volatility = best_assets$Annualized_Volatility,
    Sharpe_Ratio = best_assets$Sharpe_Ratio,
    stringsAsFactors = FALSE
  )
  
  # Ensure weights sum to 1
  portfolio_df$Weight <- portfolio_df$Weight / sum(portfolio_df$Weight)
  
  # Calculate portfolio-level metrics
  portfolio_return <- sum(portfolio_df$Weight * portfolio_df$Annualized_Return)
  # Simplified portfolio volatility (assumes some diversification benefit)
  # For a more accurate calculation, we would need correlation matrix
  portfolio_vol <- sqrt(sum(portfolio_df$Weight^2 * portfolio_df$Annualized_Volatility^2))
  # Apply diversification factor (simplified - assumes 0.3 average correlation)
  diversification_factor <- 0.7  # Accounts for diversification benefits
  portfolio_vol <- portfolio_vol * diversification_factor
  # Portfolio Sharpe Ratio
  portfolio_sharpe <- portfolio_return / portfolio_vol
  
  return(list(
    portfolio = portfolio_df,
    portfolio_metrics = list(
      expected_return = portfolio_return,
      expected_volatility = portfolio_vol,
      sharpe_ratio = portfolio_sharpe
    ),
    n_clusters = n_clusters
  ))
}

# 4. Create Donut Chart (using plotly)
create_portfolio_donut_chart <- function(portfolio_df) {
  library(plotly)
  
  # Prepare data
  plot_data <- portfolio_df %>%
    arrange(desc(Weight)) %>%
    mutate(
      Label = paste0(Ticker, "\n", round(Weight * 100, 1), "%"),
      Weight_Pct = Weight * 100
    )
  
  # Create donut chart
  fig <- plot_ly(
    plot_data,
    labels = ~Ticker,
    values = ~Weight_Pct,
    type = "pie",
    hole = 0.6,
    textinfo = "label+percent",
    textposition = "outside",
    hovertemplate = "<b>%{label}</b><br>Peso: %{percent}<br>Cluster: %{customdata}<extra></extra>",
    customdata = ~Cluster_ID
  ) %>%
    layout(
      title = list(
        text = "Alocação da Carteira Recomendada",
        font = list(size = 16)
      ),
      showlegend = TRUE,
      legend = list(orientation = "v", x = 1.1, y = 0.5),
      margin = list(l = 20, r = 20, t = 50, b = 20)
    )
  
  return(fig)
}
```

# Tab 1: Input / Suitability Questionnaire

Column {.sidebar data-width=300}
-----------------------------------------------------------------------

### Questionário de Adequação

Este dashboard utiliza algoritmos de Machine Learning (K-Means) para agrupar ativos por similaridade de risco-retorno e recomendar uma carteira personalizada baseada no seu perfil de investidor.

**Como funciona:**
1. Responda o questionário de adequação (CVM 539)
2. O sistema agrupa ativos por características similares
3. Seleciona o melhor ativo de cada grupo
4. Aloca pesos baseados no seu perfil
5. Apresenta backtest e projeções

### Configurações de Projeção

```{r projection-inputs}
# Inputs para a simulação Monte Carlo
numericInput(
  inputId = "initial_investment",
  label = "Investimento Inicial (R$)",
  value = 10000,
  min = 100,
  step = 100
)

numericInput(
  inputId = "monthly_contribution",
  label = "Contribuição Mensal (R$)",
  value = 500,
  min = 0,
  step = 50
)
```

### Manutenção de Dados

```{r maintenance-ui}
# Add this new chunk in the sidebar
actionButton(
  inputId = "update_data",
  label = "Atualizar Dados de Mercado",
  icon = icon("sync"),
  class = "btn-warning",
  style = "width: 100%; margin-top: 10px;"
)

helpText("Clique para forçar o download de novos preços e atualizar o cache.", 
         style = "font-size: 0.8em; color: #666;")
```

Column {data-width=700}
-----------------------------------------------------------------------

### Entrada de Dados

```{r render-input-tab}
renderUI({
  input_tab()
})
```

# Tab 2: Dashboard / Results

Column {data-width=500}
-------------------------------------

### Resumo da Carteira (Métricas Consolidadas)

```{r consolidated-metrics, context="server"}
# Este bloco renderiza os 6 Value Boxes de uma vez
renderUI({
  # Requer que o portfólio tenha sido gerado
  req(portfolio_data$generated)

  metrics <- portfolio_data$portfolio_metrics
  proj_results <- portfolio_data$monte_carlo_results
  
  # Usaremos uma função auxiliar para aplicar profundidade e cor
  render_card <- function(value, caption, icon, color, depth_class = "shadow-lg") {
    # Usando style para aplicar a sombra e padding para padronização
    div(
      class = paste("col-lg-2 col-md-4 col-sm-6"), 
      style = "padding: 5px;",
      flexdashboard::valueBox(
        value = value,
        caption = caption,
        icon = icon,
        color = color
      ) %>%
      # Adicionar profundidade (shadow) e ajustar bordas (rounded)
      div(class = paste("well", depth_class, "rounded-3"), style = "padding: 15px; border: 1px solid #ddd;")
    )
  }
  
  fluidRow(
    # --- BLOCO 1: MÉTRICAS DE RISCO/RETORNO ATUAL (Referência) ---
    
    # 1. Retorno Esperado
    render_card(
      value = paste0(round(metrics$expected_return * 100, 2), "%"),
      caption = "Retorno Esperado (Anualizado)",
      icon = "fa-chart-line",
      color = ifelse(metrics$expected_return > 0, "success", "danger")
    ),
    
    # 2. Volatilidade Esperada
    render_card(
      value = paste0(round(metrics$expected_volatility * 100, 2), "%"),
      caption = "Volatilidade Esperada (Anualizada)",
      icon = "fa-bolt",
      color = "warning"
    ),
    
    # 3. Sharpe Ratio
    render_card(
      value = round(metrics$sharpe_ratio, 3),
      caption = "Sharpe Ratio",
      icon = "fa-star",
      color = "primary"
    ),

    # --- BLOCO 2: PROJEÇÃO MONTE CARLO (Consolidado) ---
    
    # 4. Projeção Mediana (Cor de Projeção)
    render_card(
      value = paste0("R$ ", format(round(proj_results$final_value, 0), big.mark = ".", decimal.mark = ",")),
      caption = paste0("Projeção Mediana em ", proj_results$n_years, " anos"),
      icon = "fa-hand-holding-dollar",
      color = "info"
    ),
    
    # 5. Cenário Pessimista (P05)
    render_card(
      value = paste0("R$ ", format(round(proj_results$final_p05, 0), big.mark = ".", decimal.mark = ",")),
      caption = "Cenário Pessimista (5%)",
      icon = "fa-arrow-down-left",
      color = "gray"
    ),
    
    # 6. Cenário Otimista (P95)
    render_card(
      value = paste0("R$ ", format(round(proj_results$final_p95, 0), big.mark = ".", decimal.mark = ",")),
      caption = "Cenário Otimista (95%)",
      icon = "fa-arrow-up-right",
      color = "success"
    )
  )
})
```

### Alocação da Carteira

```{r portfolio-donut}
plotlyOutput("portfolio_donut_chart", height = "500px")
```

Column {data-width=500}
-----------------------------------------------------------------------

### Performance Histórica (Backtest 5 Anos)

```{r wealth-index-plot}
plotlyOutput("wealth_index_chart", height = "400px")

# Using a fluidRow inside the column to display Value Boxes nicely
renderUI({
  if (portfolio_data$generated && !is.null(portfolio_data$backtest_results)) {
    metrics <- portfolio_data$backtest_results$metrics
    
    fluidRow(
      # Total Return Box
      valueBox(
        value = paste0(round(metrics$total_return * 100, 1), "%"),
        subtitle = "Retorno Total Acumulado",
        icon = "fa-chart-line",
        color = ifelse(metrics$total_return > 0, "success", "danger")
      ),
      
      # Volatility Box
      valueBox(
        value = paste0(round(metrics$volatility * 100, 1), "%"),
        subtitle = "Volatilidade Anualizada",
        icon = "fa-bolt",
        color = "warning"
      ),
      
      # VaR Box
      valueBox(
        value = paste0(round(metrics$var_95 * 100, 2), "%"),
        subtitle = "VaR (95% Diário)",
        icon = "fa-shield-alt",
        color = "primary"
      ),
      
      # Max Drawdown Box
      valueBox(
        value = paste0(round(metrics$max_drawdown * 100, 1), "%"),
        subtitle = "Max Drawdown",
        icon = "fa-arrow-down",
        color = "danger"
      )
    )
  } else {
    helpText("Gere a carteira para visualizar a análise de risco.")
  }
})
```

### Projeção de Monte Carlo (5 Anos)

```{r monte-carlo-chart}
plotlyOutput("monte_carlo_projection", height = "400px")
```

Column {data-width=300}
-----------------------------------------------------------------------

### Composição Detalhada

```{r portfolio-table}
DT::dataTableOutput("portfolio_table")
```

Column {data-width=300}
-----------------------------------------------------------------------

### Risco Histórico: Drawdown da Carteira

```{r drawdown-chart}
plotlyOutput("drawdown_chart", height = "300px")
```

Column {data-width=300}
-----------------------------------------------------------------------

### Visualização dos Clusters (K-Means)

```{r cluster-visualization-plot}
sliderInput(
  inputId = "num_assets",
  label = "Número de Ativos na Carteira (k)",
  min = 4,
  max = 12,
  value = 4, # Valor inicial
  step = 1
)

plotlyOutput("cluster_plot", height = "600px")
```
